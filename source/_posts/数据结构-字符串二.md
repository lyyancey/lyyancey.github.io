---
title: 数据结构-字符串二
tags:
  - 字符串
  - KMP
categories:
  - 数据结构
math: true
date: 2021-10-19 14:49:42
excerpt: 蛮力算法为何低效
---


# 字符串 - KMP算法

## KMP算法：从记忆力到预知力

### 蛮力算法为何低效

​		如下图所示, 假定 $T$ 就是一个足够长的文本串，而上面的 $P$ 就是相对而言更短的模式串。在算法的每一步迭代中，相对于文本串模式串都有一个相应的对齐位置。注意到，在蛮力算法中，相邻的对齐位置之间间隔都是一个字符。在每一对齐位置，这个算法都需要从首字符开始，进行一系列的比对，直至在某个位置发生失配。请注意，在此之前每一次迭代所花费的时间，都正比于一个匹配的前缀。在这个图中，我们可以清晰的看到，所有这些前缀之间，存在着大量的重复。也就是说，在此前曾经参与比对的字符，在后续的迭代中，往往还会再次地参与比对。

​		如果我们将视线集中于文本串中的某一特定字符。就会发现，在最坏情况下，他有可能会与模式串中的每一个字符都比较一次。也就是说，文本串中的每一个字符，都有可能参与多达$m$次的比对。

{% asset_img 蛮力算法的典型运行过程.png  %}

- $T$ 回退、$P$ 复位之后，此前比对过的字符，将再次参与比对。

回到蛮力算法中最坏实例的例子：

{% asset_img 蛮力算法的最坏示例.png  %}

​		我们可以从这样一个新的角度，来阐释为什么蛮力算法如此低效。

​		因为站在文本串中，每一个字符的角度来看，在这种最坏情况下，他都会与模式串中的每一个字符比对一次，在这类最坏情况下，每一步迭代，都需要长途跋涉，才能够在最后一个位置

发现失配。因此，反过来这类情况之所以棘手，也可以理解为，在模式串中存在大量与文本串能够局部匹配的前缀。而蛮力算法的计算成本，也主要消耗于这些前缀中。然而在这个具体的实例进一步观察之后，我们或许会发现，这些局部匹配前缀所涉及的比对，绝大多数都是不必进行的，至少不必反复进行。

- 无论如何，还是不变性

{% asset_img 蛮力算法中的不变性.png %}

​		整个算法过程中的任何一个时刻，都可以表示为这样一幅具有一般意义的插图。在当前假设我们需要对 $T[i]$ 和 $P[j]$ 进行比对,并且根据比对的结果来确定算法的下一步走向，而这里所蕴含的不变性就是：此时比对过的文本串的子串与模式串中的前缀完全相等。这有意味着什么呢？

  - 亦即，我们业已掌握 $T[i-j, i]$ 的全部信息--- **其中的字符各是什么**。

    而这类信息，完全可以为后续的各步比对所利用。回到我们刚刚的例子：

    {% asset_img 蛮力算法中的不变性二.png %}

​		考察在当前这步迭代中的最后一次比对，也就是那次失败的比对，正如我们的不变性所指出的，尽管这次比对是失败的，但它却意味着在此前我们已经获得过足够多次成功的比对，就这个例子而言，也就是一系列的 $0-0$ 匹配。这一点其实可以概括为一条非常有用的信息，具体来说也就是**在主串中对应的这个子串，完全是由0构成的**。在这种情况下，与模式串前缀所对应的文本串的子串，完全是由$0$构成的。可惜的是，此前的蛮力算法没有注意并且充分的利用这一点。蛮力算法只会中规中矩地将模式串右移一个字符，然后试图重新与这个子串进行匹配。现在不难理解，实际上，既然无论是这个子串还是这个前缀，都是完全由$0$所构成的。所以他们任何局部比对都必然会整体成功。这也意味着，至少在当前的这种情况下，这个子串与这个模式串的任何比对，都会以完全匹配而返回。尽管他们的第一次比对确实有必要。但如果像蛮力算法那样在此后还反复地将他们进行比对，就显然是没有必要的。

### 记忆力

​		事实上，只要我们的记忆力足够强，自然也就可以将在前一轮比对中比对中所获得的上述信息存储起来，并为后续的比对所利用。而这类信息的使用原理与方法，则可以由下图来表示。在下面的图中，在当前的对其位置我们首次在$T[i]$ 和$P[j]$处发生了一次失配。而反过来$P[j]$所对应的那个前缀以及$T[i]$所对应的那个子串是完全匹配的。只要我们可以充分的利用这类信息，就可以迅速地排除掉大量的对其位置，从而令模式串得以迅速的、大幅度地向后滑动。而且，同样是利用这类信息，我们甚至可以不必去重复比对在$T[i]$之前的任何字符，也就是说在模式串的下一对齐位置，新一轮的比对只需从$T[i]$ 与新的$P[j]$开始。

{% asset_img 记忆力.png %}

### 将记忆力转化为预知力

​		依然回到我们已经多次使用的这个二进制串的实例，根据刚才的分析，在当前这轮比对失败于模式串的末字符之后，即便我们依然只能向后移动一个字符，但相对于新的$P[j]$而言，整个前缀都无需，重复比对了。也就是说，我们只需从上一次失败的位置出发，继续进行下一轮的比对。实际上，即便是对于更复杂的例子，也依然存在此类优化的可能。

{% asset_img 将记忆力转化为预知力一.png %}

​		如下图，其模式与刚才类似，也就是说相对于当前这个对齐位置，我们所做的一轮比对首次失败于 $E$ 和 $O$ 之间的失配，而是可以大胆地将它后移三个字符，也就是说此前的两个对其位置都可以排除掉。这背后的原因在于，**如果一个位置值得对齐，那么它的一个必要条件就是，所对应的首字符，应该与模式串的首字符一样都是R，而在下面的例子中，无论E或G都不是R**，这里我们再强调一次，关于这个子串的所有信息，都是我们通过前一轮的比对所获得的。而通过这个实例我们已经确实地看到，只要我们能够对这类信息充分加以利用，就可以获得两个方面的优化效果：

- 我们可能大幅度地向后滑动模式串。
- 我们也可避免大量重复的比对。

​       为了同时兑现这两个方面的优化，我们的算法实际上只需具有某一种预知力即可。具体来说也就是，**在每一次失败之后，我们应该将模式串中的哪一个字符与文本串中刚刚失败的那个字符彼此重新对齐，并继续从这个位置开始进行比对。**

那么具体又当如何来确定此类继任字符的位置呢 ？

为此我们需要花费多少时间和空间 ？

更重要的，既然是作为预知力，我们的算法能否在事先就提前确定此类继任字符串的位置呢 ？

{% asset_img 将记忆力转化为预知力二.png %}
