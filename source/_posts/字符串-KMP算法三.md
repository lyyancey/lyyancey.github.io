---
title: 数据结构-字符串三
tags:
  - 字符串
  - KMP
categories:
  - 数据结构
math: true
date: 2021-10-21 15:28:54
excerpt: KMP算法
---


# 字符串-KMP算法

## 查询表

接下来我们就看看KMP算法究竟如何兑现我们提到的记忆力以及预知力。本质上讲它无非就是构造了一张查询表。

回到我们刚刚的问题，在当前这轮比对，首次失败于$T[i]$ 与$P[j]$ 之后，我们应当如何的向后滑动模式串，从而等效的以一个新的$P[j]$ 来与刚才的$T[i]$对齐。并从这个位置开始，继续新一轮的比对。这里的好消息是新的这个$P[j]$不仅可以事先确定，而且这个位置仅取决于模式串，而与主串无关。事实上，在这样的一个时刻，主串无非四个部分，也就是文本串的这个前缀以及后最，再加上在当前这一轮已经匹配的这个子串以及失配的这个字符。此时，这个前缀与后缀对于新的这个$P[j]$字符的确没有任何影响。而文本串中与模式串相匹配的子串表面上看对$P[j]$字符有所影响，但正因为这个子串与模式串的前缀是匹配的。所以与其说这种影响是来自于文本串，不如说**最终还是来自于模式串**。

既然下一个接替的字符完全取决于模式串自身，由此出发再进一步地，与其说这个接替的字符是取决于模式串，不如说，它取决于被它顶替的此前的那个$P[j]$。事实上，在一个长度为$m$的模式串中，这样的字符$P[j]$ 无非有$m$ 种情况。而KMP算法在此处的关键诀窍在于，将所有这$m$种情况事先处理，并且归纳整理为一张查询表。在经过了这样的预处理之后，在后续的各轮比对中，一旦在某一位置$P[j]$处发生失配，我们只需简单地从查询表中取出对应的那一项，并用它来更新此前的$j$，由此可见，这种策略与其说是在借助强大的记忆力，不如说是在事先已经为各种情况准备好了充分的预案，那么基于这种以查询表的形式给出的预案，KMP算法又是如何具体工作的呢 ？

- 构造查询表$next[0, m]$ : 在任一位置$P[j]$处失败后，将$j$ 替换为$next[j]$。
- 与其说是借助强大的记忆力，不如说是做好了充分的预案。

{% asset_img 图一.png %}

## KMP的主算法

```c++
int match(char * P, char * T){
    int* next = buildNext(P); //构造next表
    int n = (int) strlen(T), i = 0; //文本串指针
    int m = (int) strlen(P), j = 0; //模式串指针
    while( j < m && i < n){ //自左向右，逐个比对字符
        if(0 > j || T[i] == P[j]){ // 若匹配
            i++; j++; //则携手共进
        }else{ // 否则，P右移，T不回退
            j = next[j];
        }
    }
    delete [] next; //释放next表
    return i - j;
}
```



## KMP算法: 理解next[] 表

### 自匹配 = 快速移动

KMP 算法的优化效果首先体现在它可以使模式串得以快速地后移，而不是如蛮力算法那样只能亦步亦趋，反过来我们也可以认为KMP可以聪明的排除掉很多不必要的对齐位置，而这些位置之所以被排除掉，是因为KMP发现它们不具备某种必要条件。正如我们马上就要看到的，这种必要条件就具体体现为模式串自身的某种匹配性。

依然回到下图这样一个串匹配的典型场景，我们在 $T[i]$ 与 $P[j]$ 之间，发现了一次失配，接下来KMP会去查询next表，取出对应的表项$t$，并用 $P[t]$ 来取代此前的$P[j]$，使之继续与此前的$T[i]$相对其，并从这个位置出发，继续后续的比对。我们的问题是，KMP在这种场合为何会选定这样一个特定的$t$ 呢？或者说这样的$t$ 又具备哪些必要条件呢？

我们来考察下图中$t$所对应的前缀，在KMP算法中，这个前缀将不再会重复的接受比对，之所以能够这样，是因为KMP已经预先判定，**这个前缀必然会与主串中对应的这个子串完全匹配**。在这里我们需要回过头来考察此前$P[j]$所对应的这个前缀。同样的，这个前缀在当年也应该和这个字串是完全匹配的。因此相对于$P[j]$所对应的子串，文本串中这个长度为$t$的子串，就是一个后缀。另一方面，既然这个新的前缀，是由此前的前缀，经过右移之后而得到的，所以同样相对于此前的这个前缀，它依然是一个长度为$t$的前缀。由此我们也就得出了一个关于$t$的一个至关重要的必要条件，也就是说，在此前的这个前缀中，必须有一个长度为$t$的后缀彼此相等，也就是说，在相对于$P[j]$而言的这个前缀中，其首部和尾部必须具有一定的相似性。

- 对任意$j$，考察集合:
  $$
  N(P,j)=\lbrace 0 \leq t < j \;\; | \; \; P[0,t) ==p[j-t, j) \rbrace
  $$

- 亦即，在$P[j]$的前缀$P[0,j)$中，所有匹配真前缀和真后缀的长度。

- 因此，一旦$T[i] \neq P[j]$ ，可从$N(P,j)$中取出某个$t$，令$P[t]$对准$T[i]$，并继续比对。

{% asset_img 图二.png %}.

###  最长自匹配 = 快速右移 + 避免回溯

 当然，在这种情况下KMP并不会去逐一尝试所有的$t$，事实上，在$next$ 表中，针对于每一项只会给出唯一的一种选择。那么KMP所选取的，究竟是其中的哪一个呢？为此我们需要考察这里的位移量，如果是用$t$ 来取代原来的$j$ ，那么对应的位移量就应该是$j$和$t$之差。在这里$j$ 是相对固定的，因此$t$越小，对应的位移就越大，反之$t$越大，相应的位移也就越小。而位移量更小，也就意味着某种意义上的更加安全。即**避免回溯**。KMP在所有候选者中最终所选取的的确就是这个集合中最大的那个$t$ ，如此可以保证对应的位移量是安全的。实际上这种原则也暗藏了另一个不变性，也就是说，由KMP所舍弃的那些对齐位置，的确都是不值得对齐的。

### 通配哨兵
至此，或许有疑问，上面的候选者集合$N(P,j)$ 一定是非空的吗。因为对于一个空集而言，无论是选取最大元还是选取任何一个元素，都是无从谈起的。然而实际上这种担心是不必要的，在这里我们注意到，只要$j$是正数，那么这个集合就必然包含$0$，然而遗憾的是$j$有可能恰好就是$0$，当然，此时$P[j]$所对应的前缀$P[0,j]$也自然是空串。而我们知道，对于空串而言，所谓的真前缀和真后缀都是不可能存在的，也就是说此时的候选集合的确是一个空集。为了修补这一漏洞，KMP算法所给出的建议是，**统一将next表中的第0项置为-1**。那么如何来理解这个-1呢？

一种形象而有效的理解方式是，为每一个模式串在首字符的前端，也就是等效于秩为-1的位置，增设一个哨兵。与假想的哨兵一样，这个哨兵不需要真实的存在。但是在逻辑上，这个哨兵却等效于一个与所有字符都通配的字符，我们在介绍KMP主算法时还有一个搁置起来的问题，也就是其中那个$if$语句所对应的条件式中$0>j$，在通常情况下，所谓的$j<0$无非就是一种情况，也就是说，在刚刚过去的那一轮比对中，我们失败于首字符$P[0]$。于是，按照我们刚才所建议的那种理解方式，KMP将用这个假想的通配符，去与文本串中失配的那个$T[i]$继续比对。既然是通配符，所以接下来的第一次比对必然会成功，也正因为此，我们可以将$j<0$的条件，在语义上与字符的成功比对等效起来。也就是说，这个合成的逻辑判断，在语义上完全等效于一次成功的比对。由此可见，巧妙地引入和设置哨兵，在程序和算法的设计过程中，是一种非常高明的处理手法。KMP就是这方面的一个典型范例。

## KMP算法:构造next[]表

接下来，我们讨论next查询表的构造算法，我们将会看到，next表的构造过程与KMP主算法的流程在本质上是完全一样的。

### 递推

- 根据已知的$next[0,j]$，如何高效地计算$next[j+1]$。

- 所谓$next(k)$，即是在$P[0,j)$中，最大自匹配的真前缀和真后缀的长度。

  - $next$表的定义：在$next$表中所谓的第$j$项，也就是在模式串长度为$j$的那个前缀中，自我匹配的真前缀与真后缀的最大长度。

- 故：$next[j+1] \leq next[j]+1$，特别的，当且仅当$P[j]==P[next[j]]$时取等号。

    由此，我们自然就可得知，在数值上，$next$表中的任何一项，相对于此前的那一项至多只可能增长一个单位，通过反证法，这一点不难得到。进一步地，这个不等式取等号的充要条件是，在模式串$P$中编号为$j$的字符与它按照$next$表的继任者彼此相等。
    
- 一般的，$P[j] \neq P[next[j]]$时，又该如何得到$next[j+1]$呢?

### 算法

在这里，我们需要牢牢抓住的要领依然是$next$表项的那个必要条件，也就是前缀的自相似性。刚刚，为了估算出$next$表的第$j+1$项，我们曾经尝试过在第$j$项的基础上去加一，因为根据刚才所建立的充要条件，只要$P[j]$与它的继任者是相等的，那么的确可以简明地通过加一得到下一项。那么即便$P[j]$与它的继任者不相等，这个必要条件依然可以适用。也就是说，在这种情况下为了估算出 $next$表的第$j+1$项，下一个值得尝试的位置，依然需要满足自相似的必要条件。那么对应的这个前缀的长度，也自然就应该是在此前长度的基础上，再去取一次对应的$next$表项。也就是说，从前缀长度的变化趋势来看，如果此前是将$j$替换为$next[j]$，那么接下来就应该将$next[j]$替换为$next[next[j]]$。当然，如果仍有必要我们应该将$next[next[j]]$替换为$next[next[next[j]]]$。这个过程有可能会持续多步，一旦遇到这样一个相等的替代者，就可以在它所对应的这个前缀长度的基础上再累进一个单位，即可得到$next$表的下一项。

- 概括而言，$next[j+1]$的候选者依次应该是：

$$
1+next[j] \\ 1+next[next[j]] \\ 1+next[next[next[j]]] \\ ...
$$

- 这个序列严格递减，且比收敛于$1+next[0] \equiv 0$。

​    在下面这副图中也就相当与模式串经过多次位移，最终居然越过了$i+1$本身，按照通常的理解，此时会出现问题，因为接下与$P[j]$进行比对的那个字符根本无从谈起。而事实上这正是我们的哨兵能够大显身手的又一个场合。我们假想的哨兵是一个通配的字符，所以作为假想的继任者，它必然在逻辑上也可等效为与$P[j]$相等。因此即使整个计算过程到了这步田地，也必然会因为这次逻辑上的判等通过而随即终止。而且此时$next$表中对应的下一项，就应该是在$-1$的基础上再加一，也就是取作0。

{% asset_img 图三.png %}

- 以上递推过程，即是$P$的自匹配过程，故只需对KMP框架略作修，二者的区别无外乎一点，也就是，新的这个算法需要实时地输出$next$表的下一项

### 实现

  next表的构造算法可以具体实现如下：

```c++
int * buildNext(char * P){  // 构造模式串P的next[]表
    size_t m = strlen(P), j = 0; // "主" 串指针
    int* N = new int[m]; // next[] 表
    int t = N[0] = -1; // 模式串指针（P[-1]通配符）
    while( j < m -1){
        if(0 > t || P[j] == P[t])//匹配
            N[++j] = ++t;
        else  //失配
            t = N[t]
    }
    return N;
}
```

​    正如刚才我们所分析的，其总体框架应该与KMP的主算法几乎一样，主要的差别有这么几点：

- 入口参数只有模式串自己。这一点不难理解，因为我们刚才讲过，整个next表的构造过程就是它自己与自己的匹配。因此在这个场合$P$既是模式串也是文本串。
- 另一点在于初始化。我们刚才已经分析过，next表的首项，也就是第0项，数值必然固定为-1.因此我们不妨就完成这一设置。



## 分摊分析

### 粗糙估计

以下我们就来对KMP算法的性能作一分析。我们知道KMP算法的计算过程可以根据对齐位置，相应的分为若干阶段。然而每一个阶段对应的计算量是有很大区别的。如果只是简单的从最坏的角度来进行估计，我们将无法准确地来评估这一算法。而实际上真正有效的方法是，放眼整个计算过程，将整体的计算成本分摊到每一个阶段。

我们首先来看一种貌似无可厚非，但是实则非常粗糙的估算方法。这一方法建议我们将注意力放在文本串中的任一字符上。因为这一方法认为我们只要估算出每一个字符所参与的比对次数，也自然的可以得到整体的比对次数。然而我们很快就会发现，在任何一个特定的字符处，我们的模式串的确可能会多次地后移。实际上不难构造出这样的例子，也就是相对于文本串中的某个特定字符，模式串有可能需要连续地后移多次，并且用其中多达$\Omega(m)$个字符与文本串中的这个字符进行比对。因此，如果再考虑到主串所贡献的那个因子$n$,那么按照这种思路，KMP的时间复杂度似乎会高达$\Omega(m*n)$。这样的一个分析结论，多少会让我们感到沮丧。因为蛮力算法也不过如此，然而事实上这种方法的确失之粗糙。接下更为精细的分析将表明，KMP算法的效率，即使在最坏情况下，也不会超过线性。

{% asset_img 图四.png %}

### 精准估计

为了对KMP算法的性能作出更为精细的分析，我们可以将这个算法中不涉及实质计算内容的非迭代部分都删除掉。

```
// 令 k = 2 * i + j
while( j < m && i < n)//k必随迭代而单调递增，故也是迭代步数的上界
	if(0 > j || T[i] == P[j]){
		i++;j++; // i j 同时加1，故k恰好加1
	}else
		j = next[j]; //i不变,j至少减一，故k至少加一
```

综合上面的代码，我们就可以发现，k随着迭代的进行的确会严格单调地不断递增。因此整个计算过程中所进行的迭代步数，就绝对不会超过k。也就是说只要我们能够界定k的上界，也就自然确定了整个算法复杂度的上界。

- k的初值为0;算法结束时，必有：

$$
k = 2*i -j \leq 2(n-1)-(-1)=2n-1=O(n)
$$

这也就意味着，在渐进的意义上，k绝对不会超过线性的范围。至此，我们也就确凿地给出了KMP算法性能的一个准确估计。

作为KMP算法的有机组成部分，我们也不能忘了next表的构造过程。正如我们已经看到的，这个预处理算法的原理及过程与主算法完全相同，因此其复杂度也应该正比于它自己的输入规模，也就是模式串的长度$m$。

## 美中不足

   ### 前车之鉴

以上我们不仅给出了KMP算法，同时也证明它的时间复杂度已经达到了渐进意义上的最优，也就是最坏情况也不会超过$O(n)$。然而该算法目前的这个版本也绝非完美无缺，接下来我们将看到在某一方面，他依然存在一个细微的瑕疵，我们要针对这一缺陷，对它再做改进

- 反例

{% asset_img 图五.png %}

其$next$查询表为：

{% asset_img 图六.png %}

与所有算法一样，KMP首先将文本串与模式串在首字符位置对齐，并启动第一轮的字符比对。不难看出，在经过三次成功的比对之后，算法将首次失败于第四个字符。于是根据算法的流程，接下来我们应该将模式串中的这个字符，替换为它对应的$next$表项所指的那个字符，也就是二号字符，因此等效于将模式串向右侧滑动一个单位，如图七。从而按照$next$表的语义，将二号字符与刚才失配的那个文本串字符对齐，并再做一次比对。

{% asset_img 图七.png %}

诚然，这次比对依然会失败。因此接下来我们将去查询二号字符在next表中所对应的那一项，也就是一号。如图八所示。从效果上看，这依旧等价于将模式串再向右滑动一个单位，从而以一号字符，与文本串中失败的这个字符再次对齐，并再做一次比对。同样不难看出，这次比对也会以失败返回，因此我们又会继而去查询这个字符所对应的$next$表项。

{% asset_img 图八.png %}

并按照这个表项的指示，将零号字符与文本串中刚才失配的那个字符对齐，并随即做一次字符的比对，再一次的，这次比对依然会以失败返回，于是根据算法的逻辑，我们将去查询首字符在$next$表中所对应的表项。从而将假想存在的那个通配哨兵与文本串中失配的字符对齐。既然是通配符，这次比对也必然会成功，从而算法终于得以越过这个位置，而从下一对字符开始，继续进行下去。

{% asset_img 图九.png %}

这里，我们更加关注的时KMP算法在这种情况下的性能表现，回过头来看一下这个例子：

{% asset_img 图五.png %}

- $T[3]$:
  - 与$P[3]$比对，失败。
  - 与$P[2]=P[next[3]]$继续比对，失败。
  - 与$P[1]=P[next[2]]$继续比对，失败。
  - 与$P[0]=P[next[1]]$继续比对，失败。
  - 最终，才前进到$T[4]$。

事实上，如果说第一次比对还是有意义的话，那么后续的三次比对实际上是多余的。从信息的角度来看，我们一开始既然就已经掌握了这个模式串的所有信息，那么自然就应该知道，在上面的例子中的最后一行个零之前的一系列字符都是零。所以在算法的执行过程中，一旦发现最后一个零与文本串不相匹配，那么自然的就应该知道，后续的这些尝试必然是徒劳的，尽管不会出错，但毕竟会白白浪费时间，那么KMP算法的这个版本，问题究竟出在哪里呢？

实际上，这个算法的主体流程并没有任何的问题。而在另一个方面，我们又注意到，控制KMP算法流程走向的，与其说是这个算法本身，不如说是它背后的那张查询表。这张$next$表既是算法策略的体现者，也是每一个模式串中所蕴含信息的具体承载者，它简明地刻画了每一个模式串的本质特征。而在当前，它只不过是刻画的还不完全而已。

这里，我们还是需要从$next$表的语义定义来说起。比如，下图中模式串索引为三的字符，它所对应的$next$表项为二。其对应的语义是说，在它所对应的这个长度为三的前缀中，存在一个长度为二的真前缀与同样长度为二的真后缀完全匹配，而且这也是如此的最长匹配，因此在经过相应的滑动之后，这两个部分也就会自然而然地匹配，从而无需对它们从新比对。在串匹配的计算过程中，相对于当前这个失配的字符，我们不仅能够知道它所对应的前缀是什么。而且，反过来我们也应该能知道这个字符不应该是什么。但是，当前KMP算法的版本还不能做到这一点。

{% asset_img 图五.png %}

### 后车之鉴

一种可行的改进方法就是，在确定各个字符所对应的$next$表项时，除了此前自相似的必要条件，我们还需增加一个新的条件。这个条件与刚才自相似的条件恰恰相反。大体而言自相似条件就等价于说，在这个前缀中存在哪些自相似的特征。而新增补的这个条件恰恰相反，他要指出新的这个字符必须与此前那个字符不一样。

```
int * buildNext(char * P){
	size_t m = strlen(P), j = 0; // "主"串指针
	int * N = new int[m]; // next 表
	int t = N[0] = -1; // 模式串指针
	while(j < m -1 ){
        if( 0 > t || P[j] = P[t]){ //匹配
        	j++;t++;N[j] = P[j] != P[t] ? t : N[t];
        }else{ // 失配
        	t = N[t]; 
        }
	}
	return N;
 }
```

**KMP算法只有在字符集足够小时，才能体现出它真正的优势！**

