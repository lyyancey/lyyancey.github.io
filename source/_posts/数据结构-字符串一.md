---
title: 数据结构-字符串一
tags:
  - 字符串
categories:
  - 数据结构
date: 2021-10-17 19:37:07
math: true
mathjax: true
excerpt: 无论是从抽象数据类型还是从具体实现的角度来看，字符串相对于之前所学的数据结构来说都更为简单。所以这里主要以讨论字符串匹配算法为主。
---


# 字符串

​	无论是从抽象数据类型还是从具体实现的角度来看，字符串相对于之前所学的数据结构来说都更为简单。所以这里主要以讨论字符串匹配算法为主。

## 字符串的 ADT

1. 定义：由来自字母表∑的字符所组成的有限序列:
   $$
   S = a_0 \quad a_1 \quad a_2 \quad \cdots \quad a_{n-1} \quad \in \sum_{}^*
   $$

   这里所讨论的字符串，其长度都要远远大于字母表的长度。

2. 相关术语与记法

   一般的,如果一个名为$S$的字符串，由$n$个字符构成，我们就将所有的字符从前至后，编号为$0$至$n-1$,并按照惯例记作$S[0, n)$。而串中秩为$k$的字符，也相应地记作$S[k]$。

   - 相等：$s[0, n)=T[0, m)$

     - 长度相等$(n==m)$,且对应字符均相同$(s[i]==T[i])$。

   - 子串：$S.substr(i, k)=S[i,i+k],\quad 0 \leq i < n, 0 \leq k$, 亦即，从$S[i]$起的连续$k$个字符：

     $$
     \fbox{[0, i)} \quad \bbox[yellow]{\fbox{[i, i+k)}}\quad \fbox{[i+k, n)}
     $$
     

   - 前缀：$S.prefix(k)=S.substr(0,k)=S[0,k),0 \leq k < n$,亦即，$S$中最靠前的$k$个字符：
     $$
     \bbox[#9ff]{\fbox{[0,k)}}\quad\fbox{[k,n)}
     $$
     

   - 后缀：$S.suffix(k)=S.substr(n-k,n),0\leq k < n$ , 亦即，$S$中最靠后的$k$个字符：

     $$
     \fbox{ [0,n-k)}\quad\bbox[#9ff]{\fbox{ [n-k,n)}}
     $$

   **联系:** $S.substr(i,k)=S.prefix(i+k).suffix(k)$

   - 空串：$S[0,n=0)$,也是任何串的子串，前缀，后缀。
   - 长度严格小于原串的子串、前缀、后缀也称作真子串、真前缀与真后缀。

3. 字符串的操作接口

   - length() : **字符串的长度。**
   - charAt(i) : **对任意给定的秩也需要能直接返回对应的字符。**
   - substr(i, k) : **子串**
   - prefix(k) : **前缀**
   - subfix(k) : **后缀**
   - concat(T) : **将某个字符串T作为后缀，与当前字符串连起来。**
   - equal(T) : **对于任意指定的字符串T，该接口可以判断T是否与当前字符串彼此相等。**
   - **indexOf(T) : 对于任意指定的一个长度为m的字符串P，该接口可以告诉我们，在当前的字符串中，是否存在某个子串与P完全相等。**
   
   
## 串匹配

1. 记 $n=\mid T \mid$ 和 $m=\mid P \mid$，通常有 $\fbox{n >> m >> 2}$ 。
2. Pattern matching
   - detection ：P是否出现 ？更加关注目标串是否出现，而非具体出现次数及位置。如病毒的监控系统。
   - location : 首次出现在哪里 ？具体出现在文本串中的位置。
   - counting : 共有几次出现 ？
   - enumeration : 各出现在哪里 ？
3. 算法评测
   - 如何客观地测量与评估串匹配算法的性能 ？ 具体采用什么标准与策略？
   - 匹配失败的概率远远的大于匹配成功的概率。
   - 随机T，对成功、失败的匹配分别测试
     - 成功 ： 在T中，随机取出长度为m的子串作为P；分析平均复杂度。
     - 失败 ： 采用随机的P; 统计平均复杂度。

## 串匹配算法

### 蛮力匹配

​		这类算法的思路与策略都是直截了当的，非常直观且易于理解。但是反过来，这个名字也暗示着它的效率是非常低下的。不过，这类算法也有它的存在价值，它可以帮助人们理解串匹配的计算过程，同时也为我们后续的改进提供了一个起点与参照。

​		**构思**：自左向右，以字符为单位，依次移动模式串，直到某个位置，发现匹配。

{% asset_img 串模式匹配的蛮力算法.png 蛮力算法的匹配过程 %}

​		上面的蛮力匹配过程至少有两种实现的版本，因为由他们可以很方便的分别导出后续更为高效的算法。所以，这里对他们都进行介绍。

版本一：

```c++
int match(char *P, char *T){
    size_t n = strlen(T), i=0;
    size_t m = strlen(P), j=0;
    while(j < m && i < n)//自左向右逐个比对字符
        if (T[i] == P[j]){ i++; j++; }//若匹配，则转到下一对字符
    	else { i -= j-1; j=0; }//否则，T会退， P复位
    return i - j;
}//如何通过返回值，判断匹配结果呢?
/**
	上面else中的代码是什么意思？
		当T 与 P 遇到第一个不匹配的字符时，
		指针在P上滑动了j个单位，同时，
		在T上也滑动了j个单位，但是，
		对于T而言，下一轮比对，要从前进一个字符开始，所以，
		要回退 j-1个单位，而对于P而言要重新开始，故，j=0；
*/
```

​		上面的算法中，$j$ 的数值对应于在当前的对其位置下，已经做过的成功比对次数。因此，一旦$j$ 达到了他的上界 $m$ ,也就意味着模式串中的这 $m$ 个字符，都得到了匹配。这是就是一次成功的匹配。此时，$i-j$ 表示，在 $i-j$ 处，发现了一次成功的匹配。

​		当 $i$ 越界时，因为 $i$ 是逐一增加的，因此它越界时必然会恰好等于 $n$ ,而此时的 $j$ 依然处于合法的区间，即$j<m$, 综合这两个条件可以得出，此时退出时，返回值 $i-j$ 必然会大于 $n-m$ ,这时，$n-m$ 应该是模式串相对于文本串而言，能够对齐的最靠右，也是最后一个位置，因此这时的 $i-j$ 既然已经超越了这个合法的位置，这个算法的上层调用者就可以据此断定，整个匹配是以失败告终的。

版本二：

```c++
int match(char *P, char *T){
    size_t n = strlen(T), i=0;		//T[i]与P[0]对齐
    size_t m = strlen(P), j; 		//T[i+j]与P[j]对齐
    for ( i = 0; i<n-m+1; i++ ){	//T从第i个字符起，与
        for ( j = 0; j<m; j++){		//P中对应的字符逐个比对
            if (T[i+j] != P[j])break; //若失配，P整体右移一个字符，重新比对
        }
        if (m <= j)break;//找到字符串
    }
    return i;
}//如何通过返回值，判断匹配结果？
```

### 复杂度

- 最好情况：

  （只经过一轮比对，即可确定匹配） ： #比对次数 = $m$ = $O(m)$，与文本串 $T$ 的长度无关

- 最坏情况：

  （每轮都比对至 $P$ 的末字符，且反复如此）

    每轮循环： 比对次数 = $m- 1$(成功) + $1$(失败)=$m$

    循环次数 = $n-m+1$

  一般地有 $m<<n$

  故总体地， 比对次数 = $m \times (n - m + 1) = O(n \times m)$

- 最坏情况真的会出现？ 是的
  - $\mid \sum \mid$ （字母表的大小）越小，最坏情况出现的概率越高。
  - 在最极端的情况下， 局部匹配的次数取决于模式串的长度$m$，$m$ 越大，最坏情况的后果更加严重。
